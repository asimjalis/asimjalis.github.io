I"∆"<h2 id="getting-to-repl">Getting to REPL</h2>

<p>Suppose you want to try out Clojure, but don‚Äôt want to spent a lot of
time setting up a project.</p>

<p>You just want to fire up the REPL and start playing with code.</p>

<p>Also you want to include other Clojure libraries dynamically on a
whim. You don‚Äôt want to declare all of them first, or restart your
REPL every time you think of a new library to pull in.</p>

<p>These steps will show you how to do this.</p>

<h2 id="boot-clj">Boot-clj</h2>

<p>First we are going to install <code class="highlighter-rouge">boot-clj</code>. Boot is similar to Lein with
the difference that it lets you define your builds in Clojure
dynamically.</p>

<p>Install <code class="highlighter-rouge">boot-clj</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install boot-clj
</code></pre></div></div>

<p>Start boot repl.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>boot repl
</code></pre></div></div>

<p>Test the REPL.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello, world!!"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>At this point the REPL should work. You can play with all the
functions that ship with Clojure.</p>

<h2 id="adding-dependencies">Adding Dependencies</h2>

<p>For most interesting applications you want to pull in dependencies
from mvnrepository or from clojars. Clojure core just isn‚Äôt enough.</p>

<p>Here is how to pull in 3rd party dependencies.</p>

<p>We are going to define a function called <code class="highlighter-rouge">deps</code> that will give us the
ability to dynamically pull in dependencies from mvnrepository or
clojars.</p>

<p>Paste this into your REPL.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Define deps to pull in dependencies dynamically</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">deps</span><span class="w"> </span><span class="p">[</span><span class="n">new-deps</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">merge-env!</span><span class="w"> </span><span class="no">:dependencies</span><span class="w"> </span><span class="n">new-deps</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="testing-with-cprint">Testing With CPrint</h2>

<p>Lets test this using cprint, which is a color pretty printing
function.</p>

<p>To use <code class="highlighter-rouge">cprint</code> we are going to pull in <code class="highlighter-rouge">lein-cprint</code> version <code class="highlighter-rouge">1.2.0</code>.
You can get the dependency name and version from mvnrepository or
clojars.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Here is how to pull in the dependency </span><span class="w">
</span><span class="p">(</span><span class="nf">deps</span><span class="w"> </span><span class="o">'</span><span class="p">[[</span><span class="n">lein-cprint</span><span class="w"> </span><span class="s">"1.2.0"</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>To use a function in the dependency we can either use <code class="highlighter-rouge">use</code> or
<code class="highlighter-rouge">requires</code>. This will pull it into our current namespace.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; `use` imports cprint directly into our namespace</span><span class="w">
</span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">'leiningen.cprint</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">cprint</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">

</span><span class="c1">; `require` imports cprint as cp/cprint in our namespace</span><span class="w">
</span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">leiningen.cprint</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">cp</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">cp/cprint</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="repl-history">REPL History</h2>

<p>Now after hacking for a bit you will want to page through your REPL
history.</p>

<p>To view the REPL history look at <code class="highlighter-rouge">.nrepl-history</code> in the directory
where you started <code class="highlighter-rouge">boot repl</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat .nrepl-history
</code></pre></div></div>

<h2 id="loading-scripts">Loading Scripts</h2>

<p>You can copy the history into a file, clean it up, and then refactor
it into an elegant script defining functions.</p>

<p>Next time you start a session you want to load the script file you
created. Here is how to load a script file into the REPL.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">load-file</span><span class="w"> </span><span class="s">"myscript.clj"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This should give you a good starting point in how to use the REPL to
interactively develop Clojure programs without getting bogged down in
setting up a project.</p>

<h2 id="repl-in-production">REPL in Production</h2>

<p>Now at this point you might say, ‚ÄúThis is a great way to goof around
in Clojure, but to put a system into production we have to put on a
serious face and give up the joys of the REPL.‚Äù</p>

<p>Not necessarily. I run production servers with a Boot REPL. You can
too. The REPL is a very powerful shell that lets you call and change
parts of your Clojure program on the fly. It‚Äôs like doing engine
repairs on a plane in flight.</p>

<p>Using the REPL you inspect and debug errors as they happen. You can
dynamically redefine functions. And most importantly you can retain
the playful REPL mindset in production.</p>

<h2 id="clojure-script-files">Clojure Script Files</h2>

<p>Can I run my Clojure scripts like I do with my Python, Ruby, Perl, and
Bash scripts?</p>

<p>Yes you can. You can run your scripts directly using this shebang line 
<code class="highlighter-rouge">#!/usr/bin/env boot</code> on top of your script file.</p>

<p>Save this into <code class="highlighter-rouge">hello.clj</code> and try it out.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">!/usr/bin/env</span><span class="w"> </span><span class="n">boot</span><span class="w">
</span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello world!"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This turns Clojure into a scripting language much like Python, Ruby,
Perl, or Bash.</p>

<h2 id="faster-startup-time">Faster Startup Time</h2>

<p>If you want to speed up your startup time you can pass JVM flags into
boot using <code class="highlighter-rouge">BOOT_JVM_OPTIONS</code>.</p>

<p>Here is how I run boot.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export BOOT_JVM_OPTIONS='
  -client
  -XX:+TieredCompilation
  -XX:TieredStopAtLevel=1
  -Xmx2g
  -XX:+UseConcMarkSweepGC
  -XX:+CMSClassUnloadingEnabled
  -Xverify:none'
</code></pre></div></div>

<p>This brings the startup time on my MacBook down from 3.2 seconds to
1.6 seconds.</p>

<p>The last flag <code class="highlighter-rouge">-Xverify:none</code> comes with the following warning from <a href="http://dev.clojure.org/display/design/Improving+Clojure+Start+Time">dev.clojure.org</a>: <em>Suppresses the bytecode verifier (which speeds classloading). Enabling this option introduces a security risk from malicious bytecode, so should be carefully considered.</em></p>

<h2 id="comments">Comments</h2>

<p>Share your thoughts on this post
<a href="https://news.ycombinator.com/item?id=13134104">here</a>.</p>

:ET